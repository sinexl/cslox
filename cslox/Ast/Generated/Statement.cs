// Generated by cslox/Ast/generate.py
// This file should not be edited manually. 
// <auto-generated />
// @formatter:off
#nullable  enable
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using System.Text;

namespace cslox.Ast.Generated;


public interface IStatementVisitor<out TResult>
{
    TResult Visit<TStatement>(TStatement statement) where TStatement : Statement;
}

public abstract class Statement 
{
    public abstract TResult Accept<TResult>(IStatementVisitor<TResult> visitor);
    public abstract string TreePrint(int indent);
    // Needed so implementers of Visitor can statically assert whether they handle all possible inheritors.
    // For static_assert in C#, see https://www.lunesu.com/archives/62-Static-assert-in-C!.html
    public const int InheritorsAmount = 11;
    public SourceLocation Location { get; set; } = new();
}

public class ExpressionStatement(Expression expression) : Statement
{
    public Expression Expression { get; set; } = expression;
    public new void Deconstruct(out Expression expression) =>
        (expression) = (Expression);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("ExpressionStatement");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Expression =\n{Expression.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Print(Expression expression) : Statement
{
    public Expression Expression { get; set; } = expression;
    public new void Deconstruct(out Expression expression) =>
        (expression) = (Expression);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Print");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Expression =\n{Expression.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class VarDeclaration(Identifier name, Expression? initializer) : Statement
{
    public Identifier Name { get; set; } = name;
    public Expression? Initializer { get; set; } = initializer;
    public new void Deconstruct(out Identifier name, out Expression? initializer) =>
        (name, initializer) = (Name, Initializer);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("VarDeclaration");
        sb.Append($" ({Name})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Initializer =\n{Initializer?.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Block(Statement[] statements) : Statement
{
    public Statement[] Statements { get; set; } = statements;
    public new void Deconstruct(out Statement[] statements) =>
        (statements) = (Statements);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Block");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Statements =\n{Statements.ArrayTreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Class(Identifier name, ReadVariable? superclass, Function[] methods) : Statement
{
    public Identifier Name { get; set; } = name;
    public ReadVariable? Superclass { get; set; } = superclass;
    public Function[] Methods { get; set; } = methods;
    public new void Deconstruct(out Identifier name, out ReadVariable? superclass, out Function[] methods) =>
        (name, superclass, methods) = (Name, Superclass, Methods);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Class");
        sb.Append($" ({Name}, {Superclass}, {Methods})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        return sb.ToString();
    }
}

public class If(Expression condition, Statement then, Statement? @else) : Statement
{
    public Expression Condition { get; set; } = condition;
    public Statement Then { get; set; } = then;
    public Statement? Else { get; set; } = @else;
    public new void Deconstruct(out Expression condition, out Statement then, out Statement? @else) =>
        (condition, then, @else) = (Condition, Then, Else);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("If");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Condition =\n{Condition.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Then =\n{Then.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Else =\n{Else?.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class While(Expression condition, Statement body) : Statement
{
    public Expression Condition { get; set; } = condition;
    public Statement Body { get; set; } = body;
    public new void Deconstruct(out Expression condition, out Statement body) =>
        (condition, body) = (Condition, Body);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("While");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Condition =\n{Condition.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Body =\n{Body.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Function(Identifier name, Identifier[] @params, Statement[] body) : Statement
{
    public Identifier Name { get; set; } = name;
    public Identifier[] Params { get; set; } = @params;
    public Statement[] Body { get; set; } = body;
    public new void Deconstruct(out Identifier name, out Identifier[] @params, out Statement[] body) =>
        (name, @params, body) = (Name, Params, Body);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Function");
        sb.Append($" ({Name}, {Params})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Body =\n{Body.ArrayTreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Break : Statement
{
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Break");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        return sb.ToString();
    }
}

public class Return(Expression? value) : Statement
{
    public Expression? Value { get; set; } = value;
    public new void Deconstruct(out Expression? value) =>
        (value) = (Value);
    public override TResult Accept<TResult>(IStatementVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Return");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Value =\n{Value?.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

// @formatter:on
// Generated by cslox/Ast/generate.py at 03.08.2025 12:29 GMT+3
// This file should not be edited manually. 
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using System;
namespace cslox.Ast.Generated;


public interface IExpressionVisitor<out TResult>
{
    TResult Visit<TExpression>(TExpression expression) where TExpression : Expression;
}

public abstract class Expression 
{
    public abstract TResult Accept<TResult>(IExpressionVisitor<TResult> visitor);
}

public class Grouping(Expression expression) : Expression
{
    public Expression Expression { get; set; } = expression;
    public new void Deconstruct(out Expression expression) =>
        (expression) = (Expression);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Grouping>(this);

}

public class Literal(object? value) : Expression
{
    public object? Value { get; set; } = value;
    public new void Deconstruct(out object? value) =>
        (value) = (Value);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Literal>(this);

}

public class Unary(Expression expression, Token @operator) : Expression
{
    public Expression Expression { get; set; } = expression;
    public Token Operator { get; set; } = @operator;
    public new void Deconstruct(out Expression expression, out Token @operator) =>
        (expression, @operator) = (Expression, Operator);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Unary>(this);

}

public abstract class Binary(Expression left, Expression right) : Expression
{
    public Expression Left { get; set; } = left;
    public Expression Right { get; set; } = right;
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Binary>(this);

}

public class Addition(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Addition>(this);

}

public class Subtraction(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Subtraction>(this);

}

public class Multiplication(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Multiplication>(this);

}

public class Division(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Division>(this);

}

public class Equality(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Equality>(this);

}

public class Inequality(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Inequality>(this);

}

public class Greater(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Greater>(this);

}

public class GreaterEqual(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<GreaterEqual>(this);

}

public class Less(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<Less>(this);

}

public class LessEqual(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit<LessEqual>(this);

}


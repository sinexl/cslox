// Generated by cslox/Ast/generate.py at 29.07.2025 11:49:04
// Do not edit this file manually.

using System;
namespace cslox.Ast.Generated;

// ReSharper disable InconsistentNaming

public abstract class Expression 
{
    public abstract TResult Accept<TResult>(IExpressionVisitor<TResult> visitor);
}

public interface IExpressionVisitor<out TResult>
{
    TResult Visit<TExpression>(TExpression expression) where TExpression : Expression;
}

public class Binary : Expression 
{
    public Expression Left { get; set; }
    public Expression Right { get; set; }
    public Token Operator { get; set; }

    public Binary(Expression _Left, Expression _Right, Token _Operator)
    {
        this.Left = _Left;
        this.Right = _Right;
        this.Operator = _Operator;
    }

    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor)
    {
        return visitor.Visit<Binary>(this);
    }

    public void Deconstruct(out Expression _Left, out Expression _Right, out Token _Operator) =>
        (_Left, _Right, _Operator) = (Left, Right, Operator);
}

public class Grouping : Expression 
{
    public Expression Expression { get; set; }

    public Grouping(Expression _Expression)
    {
        this.Expression = _Expression;
    }

    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor)
    {
        return visitor.Visit<Grouping>(this);
    }

    public void Deconstruct(out Expression _Expression) =>
        (_Expression) = (Expression);
}

public class Literal : Expression 
{
    public object? Value { get; set; }

    public Literal(object? _Value)
    {
        this.Value = _Value;
    }

    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor)
    {
        return visitor.Visit<Literal>(this);
    }

    public void Deconstruct(out object? _Value) =>
        (_Value) = (Value);
}

public class Unary : Expression 
{
    public Expression Expression { get; set; }
    public Token Operator { get; set; }

    public Unary(Expression _Expression, Token _Operator)
    {
        this.Expression = _Expression;
        this.Operator = _Operator;
    }

    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor)
    {
        return visitor.Visit<Unary>(this);
    }

    public void Deconstruct(out Expression _Expression, out Token _Operator) =>
        (_Expression, _Operator) = (Expression, Operator);
}


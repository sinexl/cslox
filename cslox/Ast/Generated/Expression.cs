// Generated by cslox/Ast/generate.py
// This file should not be edited manually. 
// <auto-generated />
// @formatter:off
#nullable  enable
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using System.Text;

namespace cslox.Ast.Generated;


public interface IExpressionVisitor<out TResult>
{
    TResult Visit<TExpression>(TExpression expression) where TExpression : Expression;
}

public abstract class Expression 
{
    public abstract TResult Accept<TResult>(IExpressionVisitor<TResult> visitor);
    public abstract string TreePrint(int indent);
    // Needed so implementers of Visitor can statically assert whether they handle all possible inheritors.
    // For static_assert in C#, see https://www.lunesu.com/archives/62-Static-assert-in-C!.html
    public const int InheritorsAmount = 25;
    public SourceLocation Location { get; set; } = new();
}

public class Grouping(Expression expression) : Expression
{
    public Expression Expression { get; set; } = expression;
    public new void Deconstruct(out Expression expression) =>
        (expression) = (Expression);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Grouping");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Expression =\n{Expression.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Literal(object? value) : Expression
{
    public object? Value { get; set; } = value;
    public new void Deconstruct(out object? value) =>
        (value) = (Value);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Literal");
        sb.Append($" ({Value})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        return sb.ToString();
    }
}

public class Unary(Expression expression, Token @operator) : Expression
{
    public Expression Expression { get; set; } = expression;
    public Token Operator { get; set; } = @operator;
    public new void Deconstruct(out Expression expression, out Token @operator) =>
        (expression, @operator) = (Expression, Operator);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Unary");
        sb.Append($" ({Operator})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Expression =\n{Expression.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Sequence(Expression[] expressions) : Expression
{
    public Expression[] Expressions { get; set; } = expressions;
    public new void Deconstruct(out Expression[] expressions) =>
        (expressions) = (Expressions);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Sequence");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Expressions =\n{Expressions.ArrayTreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class ReadVariable(Identifier name) : Expression
{
    public Identifier Name { get; set; } = name;
    public new void Deconstruct(out Identifier name) =>
        (name) = (Name);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("ReadVariable");
        sb.Append($" ({Name})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        return sb.ToString();
    }
}

public class Assign(Identifier name, Expression value) : Expression
{
    public Identifier Name { get; set; } = name;
    public Expression Value { get; set; } = value;
    public new void Deconstruct(out Identifier name, out Expression value) =>
        (name, value) = (Name, Value);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Assign");
        sb.Append($" ({Name})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Value =\n{Value.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Call(Expression callee, Expression[] arguments) : Expression
{
    public Expression Callee { get; set; } = callee;
    public Expression[] Arguments { get; set; } = arguments;
    public new void Deconstruct(out Expression callee, out Expression[] arguments) =>
        (callee, arguments) = (Callee, Arguments);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Call");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Callee =\n{Callee.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Arguments =\n{Arguments.ArrayTreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Lambda(Identifier[] @params, Statement[] body) : Expression
{
    public Identifier[] Params { get; set; } = @params;
    public Statement[] Body { get; set; } = body;
    public new void Deconstruct(out Identifier[] @params, out Statement[] body) =>
        (@params, body) = (Params, Body);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Lambda");
        sb.Append($" ({Params})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Body =\n{Body.ArrayTreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Get(Expression @object, Identifier name) : Expression
{
    public Expression Object { get; set; } = @object;
    public Identifier Name { get; set; } = name;
    public new void Deconstruct(out Expression @object, out Identifier name) =>
        (@object, name) = (Object, Name);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Get");
        sb.Append($" ({Name})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Object =\n{Object.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Set(Expression @object, Identifier name, Expression value) : Expression
{
    public Expression Object { get; set; } = @object;
    public Identifier Name { get; set; } = name;
    public Expression Value { get; set; } = value;
    public new void Deconstruct(out Expression @object, out Identifier name, out Expression value) =>
        (@object, name, value) = (Object, Name, Value);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Set");
        sb.Append($" ({Name})");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Object =\n{Object.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Value =\n{Value.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class This : Expression
{
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("This");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        return sb.ToString();
    }
}

public abstract class Binary(Expression left, Expression right) : Expression
{
    public Expression Left { get; set; } = left;
    public Expression Right { get; set; } = right;
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

}

public class Addition(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Addition");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Subtraction(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Subtraction");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Multiplication(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Multiplication");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Division(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Division");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Equality(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Equality");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Inequality(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Inequality");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Greater(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Greater");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class GreaterEqual(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("GreaterEqual");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class Less(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("Less");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class LessEqual(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("LessEqual");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class LogicalAnd(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("LogicalAnd");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

public class LogicalOr(Expression left, Expression right) : Binary(left, right)
{
    public new void Deconstruct(out Expression left, out Expression right) =>
        (left, right) = (Left, Right);
    public override TResult Accept<TResult>(IExpressionVisitor<TResult> visitor) =>
        visitor.Visit(this);

    public override string ToString() => TreePrint(indent: 0);
    public override string TreePrint(int indent)
    {
        var sb = new StringBuilder();
        var tab = new string(' ', indent * 2);
        sb.Append(tab).Append("LogicalOr");
        sb.Append('\n');
        tab = new string(' ', (indent + 1) * 2);
        sb.Append(tab).Append($"Left =\n{Left.TreePrint(indent + 2)}");
        sb.Append(tab).Append($"Right =\n{Right.TreePrint(indent + 2)}");
        return sb.ToString();
    }
}

// @formatter:on
from __future__ import annotations

import os
from ctypes import ArgumentError
from dataclasses import dataclass
from io import TextIOWrapper
from typing import Callable

TAB = " " * 4


@dataclass
class Inherited: pass;


class Ast:
    name: str
    fields: list[tuple[str, str]] | None
    ancestor: Ast | None
    inheritors: list[Ast] | None
    is_abstract: bool
    visitor_name: str | Inherited | None
    #                            File           Ast    Indent
    custom_code = list[Callable[[TextIOWrapper, "Ast", int], None]]

    def __init__(self, name: str, fields: list[tuple[str, str]] | str | None, visitor_name: str = Inherited,
                 abstract: bool = False, custom_code: None | list[Callable[[TextIOWrapper, "Ast", int], None]] = None,
                 inheritors: list["Ast"] | None = None):
        if type(fields) is str:
            self.fields = []
            for field in fields.strip().split(", "):
                assert len(field.split(" ")) == 2, f"Invalid field: {field}"
                type_name, field_name = field.split(" ")
                self.fields.append((type_name, field_name))
        else:
            self.fields = fields
        self.name = name
        self.inheritors = inheritors
        self.ancestor = None
        for i in self.inheritors or []:
            i.ancestor = self
        self.is_abstract = abstract
        self.visitor_name = visitor_name
        self.custom_code = custom_code or []

    def __str__(self):
        return self.to_str(indent=0)

    def __format__(self, format_spec: str) -> str:
        show_visitor = 'v' in format_spec
        show_ancestor = 'a' in format_spec
        show_fields = 'f' in format_spec
        return self.to_str(0, show_ancestor, show_visitor, show_fields)

    def to_str(self, indent=0, show_ancestor=False, show_visitor=False, show_fields=False) -> str:
        base = f" : {self.ancestor.name}" if show_ancestor and self.ancestor else ""
        visitor_name = self.get_visitor_name() if show_visitor else None
        visitor = f" {{ Accept({visitor_name}) }}" if visitor_name else ""
        fields = fields_as_parameters(self.fields) + " " if show_fields else ""

        result = f"{TAB * indent}{self.name}"
        result += f"{base}{fields}{visitor}\n"
        for inheritor in self.inheritors or []:
            result += inheritor.to_str(indent + 1, show_ancestor, show_visitor, show_fields)
        return result

    def get_visitor_name(self) -> str | None:
        if self.visitor_name is None: return None
        if self.visitor_name is Inherited: return self.ancestor.get_visitor_name()
        return self.visitor_name

    def get_inheritors_amount(self, count=0) -> int:
        count += 1
        for i in self.inheritors or []:
            count = i.get_inheritors_amount(count)
        return count

    def get_inheritors(self) -> set["Ast"]:
        inheritors = set()

        def impl(ast: Ast):
            inheritors.add(ast)
            for i in ast.inheritors or []:
                impl(i)

        impl(self)
        return inheritors


def get_ast_fields_or(ast: Ast | None, or_) -> list[tuple[str, str]] | None:
    if ast is None or ast.fields is None: return or_
    return ast.fields


def define_file_header(f: TextIOWrapper):
    code = \
        f"""\
// Generated by cslox/Ast/generate.py
// This file should not be edited manually. 
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using System.Text;
namespace cslox.Ast.Generated;\n\n
"""
    f.write(code)


def define_visitor(f: TextIOWrapper, base_class: str, visitor_interface_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public interface {visitor_interface_name}<out TResult>")
    f.writeln("{")
    # for type_name in types:
    #     f.writeln(f"    T Visit({type_name} _{type_name.lower()});")
    f.writeln(
        f"{TAB}TResult Visit<T{base_class}>(T{base_class} {type_to_csharp_name(base_class)}) where T{base_class} : {base_class};")
    f.writeln("}\n")


def implement_visitor(f: TextIOWrapper, ast: Ast, visitor_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    if ast.is_abstract and ast.ancestor is None:  # TODO: ast.ancestor is None is a hack
        f.writeln(f"{TAB}public abstract TResult Accept<TResult>({visitor_name}<TResult> visitor);")
    else:
        f.writeln(f"{TAB}public override TResult Accept<TResult>({visitor_name}<TResult> visitor) =>")
        # f.writeln(f"{TAB * 2}visitor.Visit<{ast.name}>(this);\n")
        f.writeln(f"{TAB * 2}visitor.Visit(this);\n")


def define_fields(f: TextIOWrapper, ast: Ast):
    f.writeln = lambda x: f.write(x + "\n")
    for field_type, field_name in ast.fields:
        f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }} = {type_to_csharp_name(field_name)};")


def define_deconstructor(f: TextIOWrapper, total_fields: list[tuple[str, str]]):
    f.writeln = lambda x: f.write(x + "\n")
    if len(total_fields) > 0:
        deconstruct_parameters = fields_as_parameters(total_fields, type_mangle=lambda x: 'out ' + x,
                                                      name_mangle=type_to_csharp_name)
        left_side = fields_as_parameters(total_fields, type_to_csharp_name, discard)
        right_side = fields_as_parameters(total_fields, type_mangle=discard)

        # Todo: putting new for every Deconstruct method is a hack, 
        #  since not all classes actually shadow it. 
        f.writeln(f"{TAB}public new void Deconstruct{deconstruct_parameters} =>")
        f.writeln(f"{TAB * 2}{left_side} = {right_side};")


def define_source_loc(f: TextIOWrapper, _: Ast, indent: int):
    f.write(f"{TAB * indent}public SourceLocation Location {{ get; set; }} = new();\n")


def define_inheritors_amount(f: TextIOWrapper | None, ast: Ast, indent: int):
    if f is None:
        raise ArgumentError("f cannot be None")
    count = ast.get_inheritors_amount()
    f.write(
        f"{TAB * indent}// Needed so implementers of Visitor can statically assert whether they handle all possible inheritors.\n"
        f"{TAB * indent}// For static_assert in C#, see https://www.lunesu.com/archives/62-Static-assert-in-C!.html\n")
    f.write(f"{TAB * indent}public const int InheritorsAmount = {count};\n")


def define_ast(f: TextIOWrapper, base_ast: Ast):
    f.writeln = lambda x: f.write(x + "\n")

    def define_ast_impl(ast: Ast):
        abstract_str = "abstract " if ast.is_abstract else ""
        inheritance = f": {ast.ancestor.name}" if ast.ancestor is not None else ""
        ancestor_fields = get_ast_fields_or(ast.ancestor, [])
        # Fields from both ancestor and derived class. Needed because constructors aren't inherited in C#. 
        total_fields = ancestor_fields + get_ast_fields_or(ast, [])

        as_parameters = fields_as_parameters(total_fields, type_to_csharp_name)
        ancestor_parameters = fields_as_parameters(ancestor_fields, type_to_csharp_name, type_mangle=discard)

        f.writeln(f"public {abstract_str}class {ast.name}{as_parameters} {inheritance}{ancestor_parameters}\n{{")

        # Fields 
        if ast.fields is not None:
            define_fields(f, ast)

        # Deconstructor 
        define_deconstructor(f, total_fields)

        # Visitor 
        visitor = ast.get_visitor_name()
        if visitor is not None:
            implement_visitor(f, ast, visitor)

        # Pretty printing 
        if ast.is_abstract and ast.ancestor is None:
            f.writeln(f"{TAB}public abstract string TreePrint(int indent);")
            pass
        elif not ast.is_abstract:
            f.writeln(f"{TAB}public override string ToString() => TreePrint(indent: 0);")
            f.writeln(f"{TAB}public override string TreePrint(int indent)\n{TAB}{{")
            f.writeln(f"{TAB * 2}var sb = new StringBuilder();")
            f.writeln(f"{TAB * 2}sb.Append(new string(' ', indent * 2)).Append(\"{ast.name}\");")
            # TODO: Factor out hierarchies 
            non_expressions = [t for t in total_fields or [] if not t[0].startswith("Expression")
                               and not t[0].startswith("Statement")]
            if len(non_expressions) > 0:
                non_expressions_as_str = fields_as_parameters(non_expressions,
                                                              name_mangle=lambda x: f"{{{x}}}",
                                                              type_mangle=discard)
                f.writeln(f"{TAB * 2}sb.Append($\" {non_expressions_as_str}\");")
            f.writeln(f"{TAB * 2}sb.Append(\'\\n\');")
            other = [t for t in total_fields if t[0].startswith("Expression") or t[0].startswith("Statement")]
            for field_type, field_name in other:
                nullable = ""
                if field_type.endswith("?"):
                    nullable = "?"
                else:
                    nullable = ""
                if not field_type.endswith("[]"):
                    f.writeln(f"{TAB * 2}sb.Append({field_name}{nullable}.TreePrint(indent + 1));")
                else:
                    f.writeln(f"{TAB * 2}sb.Append({field_name}{nullable}.ArrayTreePrint(indent + 1));")
            f.writeln(f"{TAB * 2}return sb.ToString();")
            f.writeln(f"{TAB}}}")

        for i in ast.custom_code:
            i(f, ast, 1)
        f.writeln("}\n")

        for inheritor in ast.inheritors or []:
            define_ast_impl(inheritor)

    define_ast_impl(base_ast)


def discard(_: str) -> str:
    return ''


def fields_as_parameters(fields: list[tuple] | None,
                         name_mangle: Callable[[str], str] = lambda x: x,
                         type_mangle: Callable[[str], str] = lambda x: x) -> str:
    if fields is None: return "";
    if len(fields) == 0: return "";
    result = "("
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        actual_type = type_mangle(field_type)
        result += actual_type
        # Prevent from having " Name" 
        if len(actual_type) > 0:
            result += " "
        result += name_mangle(field_name)
        if index == len(fields) - 1:
            result += ")"
        else:
            result += ", "

    return result


def type_to_csharp_name(t: str) -> str:
    t = t.lower()
    result = ""
    if t in ["operator", "if", "switch", "else", "params"]:
        result += "@"
    return result + t


def main():
    output_folder = "Generated"
    os.makedirs(output_folder, exist_ok=True)

    expression_name = "Expression"
    expression_visitor_name = "IExpressionVisitor"
    expression_ast = \
        Ast(expression_name, None, abstract=True, custom_code=[define_inheritors_amount, define_source_loc],
            visitor_name=expression_visitor_name,
            inheritors=[
                Ast("Grouping", f"{expression_name} Expression"),
                Ast("Literal", f"object? Value"),
                Ast("Unary", f"{expression_name} Expression, Token Operator"),
                Ast("Sequence", f"{expression_name}[] Expressions"),
                Ast("ReadVariable", "Identifier Name"),
                Ast("Assign", f"Identifier Name, {expression_name} Value"),
                Ast("Call", f"{expression_name} Callee, {expression_name}[] Arguments"),
                Ast("Lambda", "Identifier[] Params, Statement[] Body"),
                Ast("Binary", f"{expression_name} Left, {expression_name} Right", abstract=True, inheritors=[
                    # Arithmetics  
                    Ast("Addition", None),
                    Ast("Subtraction", None),
                    Ast("Multiplication", None),
                    Ast("Division", None),
                    # Comparison 
                    Ast("Equality", None), Ast("Inequality", None),
                    Ast("Greater", None), Ast("GreaterEqual", None),
                    Ast("Less", None), Ast("LessEqual", None),
                    # Logical 
                    Ast("LogicalAnd", None), Ast("LogicalOr", None),
                ])
            ])

    statement_name = "Statement"
    statement_visitor_name = "IStatementVisitor"
    statement_ast = \
        Ast(statement_name, None, abstract=True, custom_code=[define_inheritors_amount, define_source_loc],
            visitor_name=statement_visitor_name, inheritors=[
                Ast("ExpressionStatement", f"{expression_name} Expression"),
                Ast("Print", f"{expression_name} Expression"),
                Ast("VarDeclaration", f"Identifier Name, Expression? Initializer"),
                Ast("Block", f"{statement_name}[] Statements"),
                Ast("If", f"{expression_name} Condition, {statement_name} Then, {statement_name}? Else"),
                Ast("While", f"{expression_name} Condition, {statement_name} Body"),
                Ast("Function", f"Identifier Name, Identifier[] Params, Statement[] Body"),
                Ast("Break", None),
                Ast("Return", f"{expression_name} Value"), 
            ])
    for i in [expression_ast, statement_ast]:
        print(f"{i:f}")
        with open(f"{output_folder}/{i.name}.cs", "w") as file:
            define_file_header(file)
            define_visitor(file, i.name, i.visitor_name)
            define_ast(file, i)


if __name__ == "__main__":
    main()

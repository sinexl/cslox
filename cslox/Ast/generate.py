import os
from copyreg import constructor
from datetime import datetime
from io import TextIOWrapper
from typing import Any


def define_ast(folder: str, base_class: str, types: dict[str, str]):
    path = os.path.join(folder, f"{base_class}.cs")
    os.makedirs(folder, exist_ok=True)
    with (open(path, "w") as f):
        code = \
            f"""\
// Generated by cslox/Ast/generate.py at {datetime.now():%d.%m.%Y %H:%M:%S}
// It's not recommended to edit this file manually.

using System;
namespace cslox.Ast.Generated;

// ReSharper disable InconsistentNaming

public abstract class {base_class} {{

}}
"""
        f.write(code)
        for name, fields in types.items():
            fields = fields.strip().split(", ")
            names = list([tuple(name.split(" ")) for name in fields])

            define_type(f, base_class, name, names)


def define_type(f: TextIOWrapper, base_class_name: str, this_class_name: str, fields: list[tuple]):
    f.writeln = lambda x: f.write(x + "\n")
    tab = " " * 4
    f.writeln(f"public class {this_class_name} : {base_class_name} \n{{")
    for field_type, field_name in fields:
        f.writeln(f"{tab}public {field_type} {field_name} {{ get; set; }}")

    f.write("\n") 
    # Constructor  
    f.write(f"{tab}public {this_class_name}(")
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        f.write(f"{field_type} {field_name}")
        if index == len(fields) - 1:
            f.write(")")
        else:
            f.write(", ")
    f.write("\n")
    # Constructor Body
    f.writeln(f"{tab}{{")
    for field_type, field_name in fields: 
        f.writeln(f"{tab}{tab}this.{field_name} = {field_name};") 
    
    f.writeln(f"{tab}}}")
    
    
    f.writeln("}\n")


#     code = \
#     f"""\
# class {this_class_name}("""
#     # for (field_type, field_name) in enumerate(fields):   
#     #     code += f"{field_type} {field_name}"
#     for i in range(len(fields)): 
#         code += f"{fields[i][0]} {fields[i][1]}"
#         if i != len(fields) - 1: 
#             code += ", " 
#     code += f") : {base_class_name};"
#             
#     
#     
#     f.write(code)


if __name__ == "__main__":
    base_name = "Expression"
    define_ast("Generated", base_name, {
        "Binary": f"{base_name} Left, {base_name} Right, Token Operator",
        "Grouping": f"{base_name} Expression",
        "Literal": f"object Value",
        "Unary": f"{base_name} Expression, Token Operator",
    })

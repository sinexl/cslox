import os
from datetime import datetime
from io import TextIOWrapper

TAB = " " * 4


def define_visitor(f: TextIOWrapper, base_class: str, visitor_interface_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public interface {visitor_interface_name}<out TResult>")
    f.writeln("{")
    # for type_name in types:
    #     f.writeln(f"    T Visit({type_name} _{type_name.lower()});")
    f.writeln(f"{TAB}TResult Visit<TExpression>(TExpression expression) where TExpression : {base_class};")
    f.writeln("}\n")


def define_ast(folder: str, base_class: str, types: dict[str, str]):
    default_visitor_name = "IExpressionVisitor"
    path = os.path.join(folder, f"{base_class}.cs")
    os.makedirs(folder, exist_ok=True)
    with (open(path, "w") as f):
        code = \
            f"""\
// Generated by cslox/Ast/generate.py at {datetime.now():%d.%m.%Y %H:%M:%S}
// Do not edit this file manually.

using System;
namespace cslox.Ast.Generated;

// ReSharper disable InconsistentNaming

public abstract class {base_class} {{
    public abstract TResult Accept<TResult>({default_visitor_name}<TResult> visitor);
}}
"""
        f.write(code)
        define_visitor(f, base_class, default_visitor_name)
        for name, fields in types.items():
            fields = fields.strip().split(", ")
            names = list([tuple(name.split(" ")) for name in fields])

            define_type(f, base_class, name, names, default_visitor_name)


def define_type(f: TextIOWrapper, base_class_name: str, this_class_name: str, fields: list[tuple], visitor_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public class {this_class_name} : {base_class_name} \n{{")
    for field_type, field_name in fields:
        f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }}")

    f.write("\n")
    # Constructor  
    f.write(f"{TAB}public {this_class_name}(")
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        f.write(f"{field_type} {field_name}")
        if index == len(fields) - 1:
            f.write(")")
        else:
            f.write(", ")
    f.write("\n")
    # Constructor Body
    f.writeln(f"{TAB}{{")
    for field_type, field_name in fields:
        f.writeln(f"{TAB}{TAB}this.{field_name} = {field_name};")

    f.writeln(f"{TAB}}}\n")

    # Visitor 
    f.writeln(f"{TAB}public override TResult Accept<TResult>({visitor_name}<TResult> visitor)")
    f.writeln(f"{TAB}{{")
    f.writeln(f"{TAB}{TAB}return visitor.Visit<{this_class_name}>(this);")
    f.writeln(f"{TAB}}}")

    f.writeln("}\n")


if __name__ == "__main__":
    base_name = "Expression"
    define_ast("Generated", base_name, {
        "Binary": f"{base_name} Left, {base_name} Right, Token Operator",
        "Grouping": f"{base_name} Expression",
        "Literal": f"object Value",
        "Unary": f"{base_name} Expression, Token Operator",
    })

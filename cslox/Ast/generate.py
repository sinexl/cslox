from __future__ import annotations

import os
from dataclasses import dataclass
from datetime import datetime, timezone, timedelta
from io import TextIOWrapper
from typing import Callable

TAB = " " * 4
GMT_PLUS_THREE = timezone(timedelta(hours=3))


class Ast:
    name: str
    fields: list[tuple[str, str]] | None
    ancestor: Ast | None
    inheritors: list[Ast] | None
    is_abstract: bool

    def __init__(self, name: str, fields: list[tuple[str, str]] | str | None, custom_code=None, abstract: bool = False,
                 inheritors: list["Ast"] | None = None):
        if type(fields) is str:
            self.fields = []
            for field in fields.strip().split(", "):
                assert len(field.split(" ")) == 2, f"Invalid field: {field}"
                type_name, field_name = field.split(" ")
                self.fields.append((type_name, field_name))
        else:
            self.fields = fields
        self.name = name
        self.inheritors = inheritors
        self.ancestor = None
        for i in self.inheritors or []:
            i.ancestor = self
        self.is_abstract = abstract

    def __str__(self):
        return self.to_str(indent=0)

    def to_str(self, indent: int) -> str:
        result = ""
        result += f"{TAB * indent}{self.name}"
        result += fields_as_parameters(self.fields)
        # if self.ancestor is not None: 
        #     result += f" : {self.ancestor.name}"
        result += "\n"
        for inheritor in self.inheritors or []:
            # print(f"{TAB*indent}{TAB}Inheritor: {inheritor.name}") 
            result += inheritor.to_str(indent + 1)
        return result


def get_ast_fields_or(ast: Ast | None, or_) -> list[tuple[str, str]] | None:
    if ast is None or ast.fields is None: return or_
    return ast.fields


def define_file_header(f: TextIOWrapper):
    code = \
        f"""\
// Generated by cslox/Ast/generate.py at {datetime.now(GMT_PLUS_THREE):%d.%m.%Y %H:%M} GMT+3
// This file should not be edited manually. 
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using System;
namespace cslox.Ast.Generated;\n\n
"""
    f.write(code)


def define_visitor(f: TextIOWrapper, base_class: str, visitor_interface_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public interface {visitor_interface_name}<out TResult>")
    f.writeln("{")
    # for type_name in types:
    #     f.writeln(f"    T Visit({type_name} _{type_name.lower()});")
    f.writeln(f"{TAB}TResult Visit<TExpression>(TExpression expression) where TExpression : {base_class};")
    f.writeln("}\n")


def define_ast(f: TextIOWrapper, base_ast: Ast):
    f.writeln = lambda x: f.write(x + "\n")

    def define_ast_impl(ast: Ast):
        abstract_str = "abstract " if ast.is_abstract else ""
        inheritance = f": {ast.ancestor.name}" if ast.ancestor is not None else ""
        ancestor_fields = get_ast_fields_or(ast.ancestor, [])
        # Fields from both ancestor and derived class. Needed because constructors aren't inherited in C#. 
        constructor_fields = ancestor_fields + get_ast_fields_or(ast, [])

        as_parameters = fields_as_parameters(constructor_fields, type_to_csharp_name)
        ancestor_parameters = fields_as_parameters(ancestor_fields, type_to_csharp_name, type_mangle=discard)

        f.writeln(f"public {abstract_str}class {ast.name}{as_parameters} {inheritance}{ancestor_parameters}\n{{")
        
        # Fields 
        if ast.fields is not None:
            for field_type, field_name in ast.fields:
                f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }} = {type_to_csharp_name(field_name)};")
                
        # Deconstructor 
        if len(constructor_fields) > 0: 
            deconstruct_parameters = fields_as_parameters(constructor_fields, type_mangle=lambda x: 'out ' + x,
                                                          name_mangle=type_to_csharp_name)
            left_side = fields_as_parameters(constructor_fields, type_to_csharp_name, discard)
            right_side = fields_as_parameters(constructor_fields, type_mangle=discard)

            # Todo: putting new for every Deconstruct method is a hack, 
            #  since not all classes actually shadow it. 
            f.writeln(f"{TAB}public new void Deconstruct{deconstruct_parameters} =>")
            f.writeln(f"{TAB * 2}{left_side} = {right_side};")
        
        f.writeln("}\n")
        for inheritor in ast.inheritors or []:
            define_ast_impl(inheritor)

    define_ast_impl(base_ast)


def define_ast_old(folder: str, base_class: str, visitor_name: str, types: dict[str, str | None]):
    path = os.path.join(folder, f"{base_class}.cs")
    os.makedirs(folder, exist_ok=True)
    with (open(path, "w") as f):
        code = \
            f"""\
// Generated by cslox/Ast/generate.py at {datetime.now(GMT_PLUS_THREE):%d.%m.%Y %H:%M} GMT+3
// This file should not be edited manually. 

using System;
namespace cslox.Ast.Generated;

public abstract class {base_class} 
{{
    public abstract TResult Accept<TResult>({visitor_name}<TResult> visitor);
    
    // Current inheritors:
"""
        for name in types.keys():
            code += f"{TAB}//{TAB}{name}\n"

        f.write(code + "}\n\n")
        for name, fields in types.items():
            if fields is not None:
                fields = fields.strip().split(", ")
                names = list([tuple(name.split(" ")) for name in fields])
            else:
                names = None

            define_type_old(f, base_class, name, names, visitor_name)


def discard(_: str) -> str:
    return ''


def fields_as_parameters(fields: list[tuple] | None,
                         name_mangle: Callable[[str], str] = lambda x: x,
                         type_mangle: Callable[[str], str] = lambda x: x) -> str:
    if fields is None: return "";
    if len(fields) == 0: return "";
    result = "("
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        actual_type = type_mangle(field_type)
        result += actual_type
        # Prevent from having " Name" 
        if len(actual_type) > 0:
            result += " "
        result += name_mangle(field_name)
        if index == len(fields) - 1:
            result += ")"
        else:
            result += ", "

    return result


def type_to_csharp_name(t: str) -> str:
    t = t.lower()
    result = ""
    if t in ["operator", "if", "switch"]:
        result += "@"
    return result + t


def define_type_old(f: TextIOWrapper, base_class_name: str, this_class_name: str, fields: list[tuple] | None,
                    visitor_name: str):
    f.writeln = lambda x: f.write(x + "\n")

    as_parameters = fields_as_parameters(fields, type_to_csharp_name)

    f.writeln(f"public class {this_class_name}{as_parameters} : {base_class_name} \n{{")

    if fields is not None:
        for field_type, field_name in fields:
            f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }} = {type_to_csharp_name(field_name)};")

    f.write("\n")

    # Visitor 
    f.writeln(f"{TAB}public override TResult Accept<TResult>({visitor_name}<TResult> visitor) =>")
    f.writeln(f"{TAB * 2}visitor.Visit<{this_class_name}>(this);\n")

    # Deconstructor 
    discard = lambda _: ''

    f.writeln("}\n")


def main():
    output_folder = "Generated"
    base_name = "Expression"
    visitor_name = "IExpressionVisitor"

    ast = Ast(base_name, None, abstract=True, inheritors=[
        Ast("Grouping", f"{base_name} Expression"),
        Ast("Literal", f"object? Value"),
        Ast("Unary", f"{base_name} Expression, Token Operator"),
        Ast("Binary", f"{base_name} Left, {base_name} Right", abstract=True, inheritors=[
            Ast("Addition", None),
            Ast("Subtraction", None),
            Ast("Multiplication", None),
            Ast("Division", None),
        ])
    ])
    os.makedirs(output_folder, exist_ok=True)
    print(ast)
    with open(f"{output_folder}/{base_name}.cs", "w") as file:
        define_file_header(file)
        define_visitor(file, base_name, visitor_name)
        define_ast(file, ast)

    # define_visitor(f, "Expression", Visitor_name)
    # define_ast_old(
    #     output_folder, base_name, visitor_name, {
    #         binary_name: None,
    #         "Grouping": f"{base_name} Expression",
    #         "Literal": f"object? Value",
    #         "Unary": f"{base_name} Expression, Token Operator",
    #     })
    # define_ast_old(
    #     output_folder, binary_name, Visitor_name, {
    #         "Addition": f"{base_name} Left, {base_name} Right",
    #         "Subtraction": f"{base_name} Left, {base_name} Right",
    #         "Multiplication": f"{base_name} Left, {base_name} Right",
    #         "Division": f"{base_name} Left, {base_name} Right",
    #     }
    # )


if __name__ == "__main__":
    main()

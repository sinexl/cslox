import os
from datetime import datetime, timezone, timedelta
from io import TextIOWrapper
from typing import Callable

TAB = " " * 4
GMT_PLUS_THREE = timezone(timedelta(hours=3))

def define_visitor(f: TextIOWrapper, base_class: str, visitor_interface_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public interface {visitor_interface_name}<out TResult>")
    f.writeln("{")
    # for type_name in types:
    #     f.writeln(f"    T Visit({type_name} _{type_name.lower()});")
    f.writeln(f"{TAB}TResult Visit<TExpression>(TExpression expression) where TExpression : {base_class};")
    f.writeln("}\n")


def define_ast(folder: str, base_class: str, types: dict[str, str]):
    default_visitor_name = "IExpressionVisitor"
    path = os.path.join(folder, f"{base_class}.cs")
    os.makedirs(folder, exist_ok=True)
    with (open(path, "w") as f):
        code = \
            f"""\
// Generated by cslox/Ast/generate.py at {datetime.now(GMT_PLUS_THREE):%d.%m.%Y %H:%M} GMT+3
// This file should not be edited manually. 

using System;
namespace cslox.Ast.Generated;

public abstract class {base_class} 
{{
    public abstract TResult Accept<TResult>({default_visitor_name}<TResult> visitor);
}}

"""
        f.write(code)
        define_visitor(f, base_class, default_visitor_name)
        for name, fields in types.items():
            fields = fields.strip().split(", ")
            names = list([tuple(name.split(" ")) for name in fields])

            define_type(f, base_class, name, names, default_visitor_name)


def fields_as_parameters(fields: list[tuple], 
                         name_mangle: Callable[[str], str] = lambda x: x,
                         type_mangle: Callable[[str], str] = lambda x: x) -> str:
    result = "("
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        actual_type = type_mangle(field_type)
        result += actual_type 
        # Prevent from having " Name" 
        if len(actual_type) > 0: 
            result += " "
        result += name_mangle(field_name)
        if index == len(fields) - 1:
            result += ")"
        else:
            result += ", "

    return result

def type_to_csharp_name(t: str) -> str: 
    t = t.lower()
    result = ""
    if t in ["operator", "if", "switch"]:
        result += "@" 
    return result + t




def define_type(f: TextIOWrapper, base_class_name: str, this_class_name: str, fields: list[tuple], visitor_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    as_parameters = fields_as_parameters(fields, type_to_csharp_name)
    f.writeln(f"public class {this_class_name}{as_parameters} : {base_class_name} \n{{")
    for field_type, field_name in fields:
        f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }} = {type_to_csharp_name(field_name)};")

    f.write("\n")

    # Visitor 
    f.writeln(f"{TAB}public override TResult Accept<TResult>({visitor_name}<TResult> visitor) =>")
    f.writeln(f"{TAB}{TAB}visitor.Visit<{this_class_name}>(this);\n")

    # Deconstructor 
    discard = lambda _: ''
    deconstruct_parameters = fields_as_parameters(fields, type_mangle=lambda x: 'out ' + x, name_mangle=type_to_csharp_name)
    f.writeln(f"{TAB}public void Deconstruct{deconstruct_parameters} =>")
    f.writeln(f"{TAB*2}{fields_as_parameters(fields, type_to_csharp_name, discard)} = {fields_as_parameters(fields, type_mangle= lambda _: '')};")
    f.writeln("}\n")


if __name__ == "__main__":
    base_name = "Expression"
    define_ast("Generated", base_name, {
        "Binary": f"{base_name} Left, {base_name} Right, Token Operator",
        "Grouping": f"{base_name} Expression",
        "Literal": f"object? Value",
        "Unary": f"{base_name} Expression, Token Operator",
    })

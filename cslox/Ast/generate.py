import os
from datetime import datetime, timezone, timedelta
from io import TextIOWrapper
from typing import Callable

TAB = " " * 4
GMT_PLUS_THREE = timezone(timedelta(hours=3))


class Ast:
    name: str
    fields: list[tuple[str, str]] | None
    inheritors: list["Ast"] | None
    abstract: bool

    def __init__(self, name: str, fields: list[tuple[str, str]] | str | None, abstract: bool = False,
                 inheritors: list["Ast"] | None = None):
        if type(fields) is str:
            # self.fields = [
            #     tuple(pair.split())
            #     for pair in fields.split(", ")
            # ]
            self.fields = []
            for field in fields.strip().split(", "):
                assert len(field.split(" ")) == 2, f"Invalid field: {field}"
                type_name, field_name = field.split(" ")
                self.fields.append((type_name, field_name))
        else:
            self.fields = fields
        self.name = name
        self.inheritors = inheritors
        self.abstract = abstract

    def __str__(self):
        return self.to_str(indent=0)

    def to_str(self, indent: int) -> str:
        result = ""
        result += f"{TAB * indent}{self.name}"
        result += fields_as_parameters(self.fields) + "\n"
        for inheritor in self.inheritors or []:
            # print(f"{TAB*indent}{TAB}Inheritor: {inheritor.name}") 
            result += inheritor.to_str(indent + 1)
        return result


def define_file_header(f: TextIOWrapper):
    code = \
        f"""\
// Generated by cslox/Ast/generate.py at {datetime.now(GMT_PLUS_THREE):%d.%m.%Y %H:%M} GMT+3
// This file should not be edited manually. 

using System;
namespace cslox.Ast.Generated;\n\n
"""
    f.write(code)


def define_visitor(f: TextIOWrapper, base_class: str, visitor_interface_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public interface {visitor_interface_name}<out TResult>")
    f.writeln("{")
    # for type_name in types:
    #     f.writeln(f"    T Visit({type_name} _{type_name.lower()});")
    f.writeln(f"{TAB}TResult Visit<TExpression>(TExpression expression) where TExpression : {base_class};")
    f.writeln("}\n")


def define_ast_old(folder: str, base_class: str, visitor_name: str, types: dict[str, str | None]):
    path = os.path.join(folder, f"{base_class}.cs")
    os.makedirs(folder, exist_ok=True)
    with (open(path, "w") as f):
        code = \
            f"""\
// Generated by cslox/Ast/generate.py at {datetime.now(GMT_PLUS_THREE):%d.%m.%Y %H:%M} GMT+3
// This file should not be edited manually. 

using System;
namespace cslox.Ast.Generated;

public abstract class {base_class} 
{{
    public abstract TResult Accept<TResult>({visitor_name}<TResult> visitor);
    
    // Current inheritors:
"""
        for name in types.keys():
            code += f"{TAB}//{TAB}{name}\n"

        f.write(code + "}\n\n")
        for name, fields in types.items():
            if fields is not None:
                fields = fields.strip().split(", ")
                names = list([tuple(name.split(" ")) for name in fields])
            else:
                names = None

            define_type_old(f, base_class, name, names, visitor_name)


def fields_as_parameters(fields: list[tuple] | None,
                         name_mangle: Callable[[str], str] = lambda x: x,
                         type_mangle: Callable[[str], str] = lambda x: x) -> str:
    if fields is None: return "";
    result = "("
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        actual_type = type_mangle(field_type)
        result += actual_type
        # Prevent from having " Name" 
        if len(actual_type) > 0:
            result += " "
        result += name_mangle(field_name)
        if index == len(fields) - 1:
            result += ")"
        else:
            result += ", "

    return result


def type_to_csharp_name(t: str) -> str:
    t = t.lower()
    result = ""
    if t in ["operator", "if", "switch"]:
        result += "@"
    return result + t


def define_type_old(f: TextIOWrapper, base_class_name: str, this_class_name: str, fields: list[tuple] | None,
                    visitor_name: str):
    f.writeln = lambda x: f.write(x + "\n")

    as_parameters = fields_as_parameters(fields, type_to_csharp_name)

    f.writeln(f"public class {this_class_name}{as_parameters} : {base_class_name} \n{{")

    if fields is not None:
        for field_type, field_name in fields:
            f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }} = {type_to_csharp_name(field_name)};")

    f.write("\n")

    # Visitor 
    f.writeln(f"{TAB}public override TResult Accept<TResult>({visitor_name}<TResult> visitor) =>")
    f.writeln(f"{TAB * 2}visitor.Visit<{this_class_name}>(this);\n")

    # Deconstructor 
    discard = lambda _: ''
    deconstruct_parameters = fields_as_parameters(fields, type_mangle=lambda x: 'out ' + x,
                                                  name_mangle=type_to_csharp_name)
    left_side = fields_as_parameters(fields, type_to_csharp_name, discard)
    right_side = fields_as_parameters(fields, type_mangle=discard)

    f.writeln(f"{TAB}public void Deconstruct{deconstruct_parameters} =>")
    f.writeln(f"{TAB * 2}{left_side} = {right_side};")

    f.writeln("}\n")


if __name__ == "__main__":
    output_folder = "Generated"
    base_name = "Expression"
    binary_name = "Binary"
    Visitor_name = "IExpressionVisitor"

    ast = Ast(base_name, None, abstract=True, inheritors=[
        Ast("Grouping", f"{base_name} Expression"),
        Ast("Literal", f"object? Value"),
        Ast("Unary", f"{base_name} Expression, Token Operator"),
        Ast("Binary", f"{base_name} Left, {base_name} Right", abstract=True, inheritors=[
            Ast("Addition", None),
            Ast("Subtraction", None),
            Ast("Multiplication", None),
            Ast("Division", None),
        ])
    ])
    os.makedirs(output_folder, exist_ok=True) 
    with open(f"{output_folder}/{base_name}.cs", "w") as file: 
        define_file_header(file) 
        define_ast(ast)
    print(ast)
    
    exit(0)

    # define_visitor(f, "Expression", Visitor_name)
    define_ast_old(
        output_folder, base_name, Visitor_name, {
            binary_name: None,
            "Grouping": f"{base_name} Expression",
            "Literal": f"object? Value",
            "Unary": f"{base_name} Expression, Token Operator",
        })
    define_ast_old(
        output_folder, binary_name, Visitor_name, {
            "Addition": f"{base_name} Left, {base_name} Right",
            "Subtraction": f"{base_name} Left, {base_name} Right",
            "Multiplication": f"{base_name} Left, {base_name} Right",
            "Division": f"{base_name} Left, {base_name} Right",
        }
    )

from __future__ import annotations

import os
from dataclasses import dataclass
from datetime import datetime, timezone, timedelta
from io import TextIOWrapper
from types import NoneType
from typing import Callable

TAB = " " * 4
GMT_PLUS_THREE = timezone(timedelta(hours=3))


@dataclass
class Inherited: pass;


class Ast:
    name: str
    fields: list[tuple[str, str]] | None
    ancestor: Ast | None
    inheritors: list[Ast] | None
    is_abstract: bool
    visitor_name: str | Inherited | None

    def __init__(self, name: str, fields: list[tuple[str, str]] | str | None, visitor_name: str = Inherited,
                 abstract: bool = False,
                 inheritors: list["Ast"] | None = None):
        if type(fields) is str:
            self.fields = []
            for field in fields.strip().split(", "):
                assert len(field.split(" ")) == 2, f"Invalid field: {field}"
                type_name, field_name = field.split(" ")
                self.fields.append((type_name, field_name))
        else:
            self.fields = fields
        self.name = name
        self.inheritors = inheritors
        self.ancestor = None
        for i in self.inheritors or []:
            i.ancestor = self
        self.is_abstract = abstract
        self.visitor_name = visitor_name

    def __str__(self):
        return self.to_str(indent=0)

    def to_str(self, indent: int) -> str:
        result = ""
        result += f"{TAB * indent}{self.name}"
        result += fields_as_parameters(self.fields)
        # Todo: Use into format arguments if possible instead of comments
        # if self.ancestor is not None: 
        #     result += f" : {self.ancestor.name}"
        # if visitor := self.get_visitor_name() is not None:  
        #     result += f" {{ Accept({visitor}) }}" 
        result += "\n"
        for inheritor in self.inheritors or []:
            # print(f"{TAB*indent}{TAB}Inheritor: {inheritor.name}") 
            result += inheritor.to_str(indent + 1)
        return result

    def get_visitor_name(self) -> str | None:
        if self.visitor_name is None: return None
        if self.visitor_name is Inherited: return self.ancestor.get_visitor_name()
        return self.visitor_name


def get_ast_fields_or(ast: Ast | None, or_) -> list[tuple[str, str]] | None:
    if ast is None or ast.fields is None: return or_
    return ast.fields


def define_file_header(f: TextIOWrapper):
    code = \
        f"""\
// Generated by cslox/Ast/generate.py at {datetime.now(GMT_PLUS_THREE):%d.%m.%Y %H:%M} GMT+3
// This file should not be edited manually. 
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using System;
namespace cslox.Ast.Generated;\n\n
"""
    f.write(code)


def define_visitor(f: TextIOWrapper, base_class: str, visitor_interface_name: str):
    f.writeln = lambda x: f.write(x + "\n")
    f.writeln(f"public interface {visitor_interface_name}<out TResult>")
    f.writeln("{")
    # for type_name in types:
    #     f.writeln(f"    T Visit({type_name} _{type_name.lower()});")
    f.writeln(f"{TAB}TResult Visit<TExpression>(TExpression expression) where TExpression : {base_class};")
    f.writeln("}\n")


def define_ast(f: TextIOWrapper, base_ast: Ast):
    f.writeln = lambda x: f.write(x + "\n")

    def define_ast_impl(ast: Ast):
        abstract_str = "abstract " if ast.is_abstract else ""
        inheritance = f": {ast.ancestor.name}" if ast.ancestor is not None else ""
        ancestor_fields = get_ast_fields_or(ast.ancestor, [])
        # Fields from both ancestor and derived class. Needed because constructors aren't inherited in C#. 
        constructor_fields = ancestor_fields + get_ast_fields_or(ast, [])

        as_parameters = fields_as_parameters(constructor_fields, type_to_csharp_name)
        ancestor_parameters = fields_as_parameters(ancestor_fields, type_to_csharp_name, type_mangle=discard)

        f.writeln(f"public {abstract_str}class {ast.name}{as_parameters} {inheritance}{ancestor_parameters}\n{{")

        # Fields 
        if ast.fields is not None:
            for field_type, field_name in ast.fields:
                f.writeln(f"{TAB}public {field_type} {field_name} {{ get; set; }} = {type_to_csharp_name(field_name)};")

        # Deconstructor 
        if len(constructor_fields) > 0:
            deconstruct_parameters = fields_as_parameters(constructor_fields, type_mangle=lambda x: 'out ' + x,
                                                          name_mangle=type_to_csharp_name)
            left_side = fields_as_parameters(constructor_fields, type_to_csharp_name, discard)
            right_side = fields_as_parameters(constructor_fields, type_mangle=discard)

            # Todo: putting new for every Deconstruct method is a hack, 
            #  since not all classes actually shadow it. 
            f.writeln(f"{TAB}public new void Deconstruct{deconstruct_parameters} =>")
            f.writeln(f"{TAB * 2}{left_side} = {right_side};")

        # Visitor 
        visitor = ast.get_visitor_name()
        if visitor is not None:
            if ast.is_abstract and ast.ancestor is None:  # TODO: ast.ancestor is None is a hack
                f.writeln(f"{TAB}public abstract TResult Accept<TResult>({visitor}<TResult> visitor);")
            else:
                f.writeln(f"{TAB}public override TResult Accept<TResult>({visitor}<TResult> visitor) =>")
                f.writeln(f"{TAB * 2}visitor.Visit<{ast.name}>(this);\n")
        f.writeln("}\n")
        for inheritor in ast.inheritors or []:
            define_ast_impl(inheritor)

    define_ast_impl(base_ast)


def discard(_: str) -> str:
    return ''


def fields_as_parameters(fields: list[tuple] | None,
                         name_mangle: Callable[[str], str] = lambda x: x,
                         type_mangle: Callable[[str], str] = lambda x: x) -> str:
    if fields is None: return "";
    if len(fields) == 0: return "";
    result = "("
    for index in range(len(fields)):
        field_type, field_name = fields[index]
        actual_type = type_mangle(field_type)
        result += actual_type
        # Prevent from having " Name" 
        if len(actual_type) > 0:
            result += " "
        result += name_mangle(field_name)
        if index == len(fields) - 1:
            result += ")"
        else:
            result += ", "

    return result


def type_to_csharp_name(t: str) -> str:
    t = t.lower()
    result = ""
    if t in ["operator", "if", "switch"]:
        result += "@"
    return result + t


def main():
    output_folder = "Generated"
    base_name = "Expression"
    visitor_name = "IExpressionVisitor"

    ast = Ast(base_name, None, abstract=True, visitor_name=visitor_name, inheritors=[
        Ast("Grouping", f"{base_name} Expression"),
        Ast("Literal", f"object? Value"),
        Ast("Unary", f"{base_name} Expression, Token Operator"),
        Ast("Binary", f"{base_name} Left, {base_name} Right", abstract=True, inheritors=[
            Ast("Addition", None),
            Ast("Subtraction", None),
            Ast("Multiplication", None),
            Ast("Division", None),
        ])
    ])
    os.makedirs(output_folder, exist_ok=True)
    print(ast)
    with open(f"{output_folder}/{base_name}.cs", "w") as file:
        define_file_header(file)
        define_visitor(file, base_name, visitor_name)
        define_ast(file, ast)


if __name__ == "__main__":
    main()
